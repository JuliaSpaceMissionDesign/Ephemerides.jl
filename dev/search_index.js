var documenterSearchIndex = {"docs":
[{"location":"tutorials/load/#Loading-Kernels","page":"Loading Kernels","title":"Loading Kernels","text":"","category":"section"},{"location":"tutorials/load/","page":"Loading Kernels","title":"Loading Kernels","text":"This tutorial will walk you through the basic features and interfaces that allow you to load binary ephemeris kernels.","category":"page"},{"location":"tutorials/load/","page":"Loading Kernels","title":"Loading Kernels","text":"The supported sources of ephemerides are currently limited to binary PCK and SPK segments of type: 1, 2, 3, 8, 9, 12, 13, 18, 19, 20 and 21. ","category":"page"},{"location":"tutorials/load/","page":"Loading Kernels","title":"Loading Kernels","text":"note: Note\nSupport for IMCCE INPOP ephemerides is yet to be implemented.","category":"page"},{"location":"tutorials/load/","page":"Loading Kernels","title":"Loading Kernels","text":"Before retrieving position and orientation data of celestial objects, the user is first required to load the ephemerides files into an EphemerisProvider object. ","category":"page"},{"location":"tutorials/load/","page":"Loading Kernels","title":"Loading Kernels","text":"using Ephemerides \n\n# Load a single ephemeris file \neph1 = EphemerisProvider(\"kernel1.bsp\")\n\n# Load multiple ephemeris files simultaneously\neph2 = EphemerisProvider([\"kernel1.bsp\", \"kernel2.bsp\"])","category":"page"},{"location":"tutorials/load/","page":"Loading Kernels","title":"Loading Kernels","text":"You must specify the relative or absolute path(s) of the file(s) to load. Either one or multiple ephemeris files can be simultaneously loaded into a single EphemerisProvider object. However,  once a provider has been created, no more kernels can be loaded inside it. ","category":"page"},{"location":"benchmarks/#Performance-Benchmarks","page":"Benchmarks","title":"Performance Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The performance of this package have been tested against both CALCEPH and SPICE, two of the most-popular open-source ephemeris readers used in the space industry.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The results show that Ephemerides.jl largely outperforms SPICE as well as CALCEPH for most SPK segment types. For example, for state vector computations (i.e., position and velocity) the mean execution times are the following:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"<p align=\"center\">\n<img src=\"https://github.com/JuliaSpaceMissionDesign/Ephemerides.jl/assets/85893254/e54ac790-7421-47ff-9b68-d35bdea74de5\" width=\"512\"/>\n</p>","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Additionally, it is better optimised to compute higher order derivatives (i.e., acceleration and jerk) with respect to CALCEPH. ","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"<p align=\"center\">\n<img src=\"https://github.com/JuliaSpaceMissionDesign/Ephemerides.jl/assets/85893254/ec2df247-9dde-44e9-82f4-4e8372317b8e\" width=\"512\"/>\n</p>","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"note: Note\nThese time benchmarks have been obtained on an Intel Core i7-6700 CPU @ 3.40 GHz with 16 GB of RAM","category":"page"},{"location":"api/lapi/#ephemerides_api","page":"Low-level API","title":"Low-level API","text":"","category":"section"},{"location":"api/lapi/","page":"Low-level API","title":"Low-level API","text":"This functions are not meant to be used outside of the package. They are documented  only to aid future developments of the package.","category":"page"},{"location":"api/lapi/#Ephemeris-Provider","page":"Low-level API","title":"Ephemeris Provider","text":"","category":"section"},{"location":"api/lapi/","page":"Low-level API","title":"Low-level API","text":"Ephemerides.get_daf \nEphemerides.spk_links \nEphemerides.pck_links","category":"page"},{"location":"api/lapi/#Ephemerides.get_daf","page":"Low-level API","title":"Ephemerides.get_daf","text":"daf(eph::EphemerisProvider)\n\nReturn the DAF files stored in the ephemeris provider. \n\n\n\n\n\ndaf(eph::EphemerisProvider, id::Int)\n\nReturn the DAF file in the ephemeris provider at index id.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.spk_links","page":"Low-level API","title":"Ephemerides.spk_links","text":"spk_links(eph::EphemerisProvider)\n\nReturn the [SPKLinkTable] for the SPK segments.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.pck_links","page":"Low-level API","title":"Ephemerides.pck_links","text":"pck_links(eph::EphemerisProvider)\n\nReturn the SPKLinkTable for the PCK segments.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#DAF-Routines","page":"Low-level API","title":"DAF Routines","text":"","category":"section"},{"location":"api/lapi/#DAF-Header","page":"Low-level API","title":"DAF Header","text":"","category":"section"},{"location":"api/lapi/","page":"Low-level API","title":"Low-level API","text":"Ephemerides.DAFHeader \n\nEphemerides.initial_record \nEphemerides.final_record \nEphemerides.free_address\nEphemerides.endian \nEphemerides.filename \nEphemerides.summary_size","category":"page"},{"location":"api/lapi/#Ephemerides.DAFHeader","page":"Low-level API","title":"Ephemerides.DAFHeader","text":"DAFHeader\n\nThe DAF header, or file record, is the first physical record in a DAF and stores general  information about the content of the file. \n\nFields\n\nnd – Int32 number of double components in each array summary\nni – Int32 number of integer components in each array summary\nfwd – Int32 record number of initial summary record\nbwd – Int32 record number of final summary record\nffa – Int32 first free address of the file \nname – String internal name of the file\nlend – Bool true if the file was generated in little endian \n\nReferences\n\nDAF Required Reading\n\nSee Also\n\nSee also DAF and EphemerisProvider\n\n\n\n\n\n","category":"type"},{"location":"api/lapi/#Ephemerides.initial_record","page":"Low-level API","title":"Ephemerides.initial_record","text":"initial_record(head::DAFHeader)\n\nReturn the record number of the initial summary record in the DAF \n\n\n\n\n\ninitial_record(daf::DAF)\n\nReturn the record number of the initial summary record in the DAF.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.final_record","page":"Low-level API","title":"Ephemerides.final_record","text":"final_record(head::DAFHeader)\n\nReturn the record number of the final summary record in the DAF \n\n\n\n\n\nfinal_record(daf::DAF)\n\nReturn the record number of the final summary record in the DAF.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.free_address","page":"Low-level API","title":"Ephemerides.free_address","text":"free_address(head::DAFHeader)\n\nReturn the first free address in the file, i.e., the address at which the first element of  the next array is to be added.\n\n\n\n\n\nfree_address(daf::DAF)\n\nReturn the first free address in the file, i.e., the address at which the first element of  the next array is to be added.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.endian","page":"Low-level API","title":"Ephemerides.endian","text":"endian(head::DAFHeader)\n\nReturn true if the DAF file is in little-endian.\n\n\n\n\n\nendian(daf::DAF)\n\nReturn true if the DAF is in little-endian.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.filename","page":"Low-level API","title":"Ephemerides.filename","text":"filename(head::DAFHeader)\n\nReturn the internal description of the DAF.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.summary_size","page":"Low-level API","title":"Ephemerides.summary_size","text":"summary_size(head::DAFHeader)\n\nCompute the size of a single summary record of a DAF file, in bytes.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#DAF-Descriptor","page":"Low-level API","title":"DAF Descriptor","text":"","category":"section"},{"location":"api/lapi/","page":"Low-level API","title":"Low-level API","text":"Ephemerides.DAFSegmentDescriptor \n\nEphemerides.segment_type \nEphemerides.initial_time\nEphemerides.final_time\nEphemerides.center\nEphemerides.target\nEphemerides.axes\nEphemerides.initial_address\nEphemerides.final_address\n\nEphemerides.get_segment_boundaries\n\nEphemerides.parse_spk_segment_descriptor\nEphemerides.parse_pck_segment_descriptor","category":"page"},{"location":"api/lapi/#Ephemerides.DAFSegmentDescriptor","page":"Low-level API","title":"Ephemerides.DAFSegmentDescriptor","text":"DAFSegmentDescriptor\n\nA container object to store both SPK and PCK descriptors information.\n\nFields\n\nsegtype – Int32 SPK/PCK segment type\ntstart – Float64 initial segment type, in TDB seconds since J2000.0\ntend – Float64 final segment type, in TDB seconds since J2000.0\ntid – Int32 target object NAIF ID\ncid – Int32 center object NAIF ID\naxesid – Int32 reference axes ID. Defaults to -1 for PCKs\niaa – Int32 initial array address\nfaa – Int32 final array address\n\nReferences\n\nSPK Required Reading\nPCK Required Reading\n\n\n\n\n\n","category":"type"},{"location":"api/lapi/#Ephemerides.segment_type","page":"Low-level API","title":"Ephemerides.segment_type","text":"segment_type(desc::DAFSegmentDescriptor)\n\nReturn the SPK/PCK segment type.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.initial_time","page":"Low-level API","title":"Ephemerides.initial_time","text":"initial_time(desc::DAFSegmentDescriptor)\n\nReturn the initial epoch of the interval for which ephemeris data are contained in the  segment, in seconds since J2000.0\n\n\n\n\n\ninitial_time(link::SPKLink)\n\nReturn the initial epoch of the interval for which ephemeris data are contained in the  segment associated to this link, in seconds since J2000.0\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.final_time","page":"Low-level API","title":"Ephemerides.final_time","text":"final_time(desc::DAFSegmentDescriptor)\n\nReturn the final epoch of the interval for which ephemeris data are contained in the  segment, in seconds since J2000.0\n\n\n\n\n\nfinal_time(link::SPKLink)\n\nReturn the final epoch of the interval for which ephemeris data are contained in the  segment associated to this link, in seconds since J2000.0\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.center","page":"Low-level API","title":"Ephemerides.center","text":"center(desc::DAFSegmentDescriptor)\n\nReturn the NAIF integer code for the reference object or axes for SPK and PCK, respectively.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.target","page":"Low-level API","title":"Ephemerides.target","text":"target(desc::DAFSegmentDescriptor)\n\nReturn the NAIF integer code for the target object or axes for SPK and PCK, respectively.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.axes","page":"Low-level API","title":"Ephemerides.axes","text":"axes(desc::DAFSegmentDescriptor)\n\nReturn the NAIF integer code for the reference axes. It is valid only for SPK files and  defaults to -1 for PCKs. \n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.initial_address","page":"Low-level API","title":"Ephemerides.initial_address","text":"initial_address(desc::DAFSegmentDescriptor)\n\nReturn the initial address of the segment array in the DAF.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.final_address","page":"Low-level API","title":"Ephemerides.final_address","text":"final_address(desc::DAFSegmentDescriptor)\n\nReturn the final address of the segment array in teh DAF.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.get_segment_boundaries","page":"Low-level API","title":"Ephemerides.get_segment_boundaries","text":"get_segment_boundaries(desclist::Vector{DAFSegmentDescriptor})\n\nParse all the segment descriptors of a given (center, target) pair and return a set of  initial and final times, in TDB seconds since J2000, representing all the time  sub-windows in which the ephemeris data for this pair is defined. \n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.parse_spk_segment_descriptor","page":"Low-level API","title":"Ephemerides.parse_spk_segment_descriptor","text":"parse_spk_segment_descriptor(summary::Vector{UInt8}, lend::Bool)\n\nCreate a DAFSegmentDescriptor object by parsing a binary SPK segment descriptor.\n\nReferences\n\nSPK Required Reading\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.parse_pck_segment_descriptor","page":"Low-level API","title":"Ephemerides.parse_pck_segment_descriptor","text":"parse_pck_segment_descriptor(summary::Vector{UInt8}, lend::Bool)\n\nCreate a DAFSegmentDescriptor object by parsing a binary PCK segment descriptor.  A default value of -1 is used to fill the reference frame field. The target and center fields are used for the actual target and center axes.\n\nReferences\n\nPCK Required Reading\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#DAF","page":"Low-level API","title":"DAF","text":"","category":"section"},{"location":"api/lapi/","page":"Low-level API","title":"Low-level API","text":"Ephemerides.DAF\nEphemerides.DAF_RECORD_LENGTH\nEphemerides.FTPSTR\n\nEphemerides.comment\nEphemerides.header\nEphemerides.array\nEphemerides.descriptors\nEphemerides.segment_list\nEphemerides.filepath\nEphemerides.is_spk\nEphemerides.is_pck\n\nEphemerides.parse_daf_comment\nEphemerides.parse_daf_summaries\n\nEphemerides.initialise_segments!\nEphemerides.create_spk_segment\n\nEphemerides.get_record\nEphemerides.is_little_endian","category":"page"},{"location":"api/lapi/#Ephemerides.DAF","page":"Low-level API","title":"Ephemerides.DAF","text":"DAF\n\nContainer to hold the information of NAIF's Double precision Array File (DAF). \n\nFields\n\nfilepath – String system filepath of the DAF \narray – Vector{UInt8} binary content of the DAF\nheader – DAFHeader file record of the DAF\ncomment – String text within the DAF comment area \nftype – Int file type, equals 1 for SPK and 2 for PCK\ndesc – DAF PCK/SPK segment descriptors\nseglist – SPKSegmentList list of the SPK/PCK segments within the DAF\n\nReferences\n\nDAF Required Reading\n\nSee Also\n\nSee also DAFHeader, Ephemerides.SPKSegmentList and EphemerisProvider\n\n\n\n\n\n","category":"type"},{"location":"api/lapi/#Ephemerides.DAF_RECORD_LENGTH","page":"Low-level API","title":"Ephemerides.DAF_RECORD_LENGTH","text":"DAF_RECORD_LENGTH\n\nDAF record length, in bytes.\n\nReferences\n\nDAF Required Reading\n\n\n\n\n\n","category":"constant"},{"location":"api/lapi/#Ephemerides.FTPSTR","page":"Low-level API","title":"Ephemerides.FTPSTR","text":"FTPSTR\n\nValidation string that guarantees the integrity of a DAF file. \n\nReferences\n\nDAF Required Reading\n\n\n\n\n\n","category":"constant"},{"location":"api/lapi/#Ephemerides.comment","page":"Low-level API","title":"Ephemerides.comment","text":"get_comment(daf::DAF)\n\nReturn the comment written in the DAF comment section. \n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.header","page":"Low-level API","title":"Ephemerides.header","text":"header(spk::AbstractSPKSegment)\n\nReturn the segment header.\n\n\n\n\n\nget_header(daf::DAF)\n\nReturn the DAFHeader header of the DAF.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.array","page":"Low-level API","title":"Ephemerides.array","text":"get_array(daf::DAF)\n\nReturn the byte content of the DAF file.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.descriptors","page":"Low-level API","title":"Ephemerides.descriptors","text":"get_descriptors(daf::DAF)\n\nReturn the SPK/PCK segment descriptors contained in the DAF.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.segment_list","page":"Low-level API","title":"Ephemerides.segment_list","text":"get_segment_list(daf::DAF)\n\nReturn the Ephemerides.SPKSegmentList list of segments stored in the DAF.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.filepath","page":"Low-level API","title":"Ephemerides.filepath","text":"filepath(daf::DAF)\n\nReturn the system path of the DAF.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.is_spk","page":"Low-level API","title":"Ephemerides.is_spk","text":"is_spk(daf::DAF)\n\nReturn true if the DAF stores SPK data.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.is_pck","page":"Low-level API","title":"Ephemerides.is_pck","text":"is_pck(daf::DAF)\n\nReturn true if the DAF stores PCK data.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.parse_daf_comment","page":"Low-level API","title":"Ephemerides.parse_daf_comment","text":"parse_daf_comment(array::Vector{UInt8}, header::DAFHeader)\n\nRetrieve the comment section of a binary DAF.\n\nReferences\n\nDAF Required Reading\n\nSee Also\n\nSee also DAF, DAFHeader and parse_daf_summaries\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.parse_daf_summaries","page":"Low-level API","title":"Ephemerides.parse_daf_summaries","text":"parse_daf_summaries(array::Vector{UInt8}, head::DAFHeader)\n\nParse the DAF binary content and retrieve all the summary records.\n\nReferences\n\nDAF Required Reading\n\nSee Also\n\nSee also DAF, DAFHeader and parse_daf_comment\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.initialise_segments!","page":"Low-level API","title":"Ephemerides.initialise_segments!","text":"initialise_segments!(daf::DAF)\n\nFill the Ephemerides.SPKSegmentList by initialising the SPK/PCK segments associated to all  the descriptors stores within the DAF.\n\nSee Also\n\nSee also DAF and create_spk_segment\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.create_spk_segment","page":"Low-level API","title":"Ephemerides.create_spk_segment","text":"create_spk_segment(daf::DAF, desc::DAFSegmentDescriptor)\n\nInitialise an SPK segment according to the segment type defined in the  DAFSegmentDescriptor desc.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.get_record","page":"Low-level API","title":"Ephemerides.get_record","text":"get_record(array::Vector{UInt8}, index::Integer)\n\nRetrieve a whole DAF record at position index.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.is_little_endian","page":"Low-level API","title":"Ephemerides.is_little_endian","text":"is_little_endian(array::Vector{UInt8})\n\nReturn true if the array corresponds to the string indicating a little-endian format.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#SPK-Links","page":"Low-level API","title":"SPK Links","text":"","category":"section"},{"location":"api/lapi/","page":"Low-level API","title":"Low-level API","text":"Ephemerides.SPKLink \nEphemerides.SPKLinkTable\n\nEphemerides.descriptor \nEphemerides.file_id\nEphemerides.list_id\nEphemerides.element_id\nEphemerides.factor\nEphemerides.reverse_link\nEphemerides.create_linktables\nEphemerides.add_spklinks!","category":"page"},{"location":"api/lapi/#Ephemerides.SPKLink","page":"Low-level API","title":"Ephemerides.SPKLink","text":"SPKLink\n\nA link object to create a mapping between DAFSegmentDescriptor and its actual  location within an EphemerisProvider object. \n\nFields\n\ndesc – DAFSegmentDescriptor for the segment associated to this link\nfid – Int index of the DAF containg the link data.\nlid – Int field number in the SPKSegmentList for this segment type.\neid – Int index of the inner segment list that stores this SPK segment.\nfct – Int 1 or -1 depending on whether the (from, to) directions must be reversed.\n\nSee Also\n\nSee also SPKLinkTable, SPKSegmentList and add_spklinks!.\n\n\n\n\n\n","category":"type"},{"location":"api/lapi/#Ephemerides.SPKLinkTable","page":"Low-level API","title":"Ephemerides.SPKLinkTable","text":"SPKLinkTable\n\nDictionary object providing all the SPKLink available between a set of (from, to) objects\n\n\n\n\n\n","category":"type"},{"location":"api/lapi/#Ephemerides.descriptor","page":"Low-level API","title":"Ephemerides.descriptor","text":"descriptor(link::SPKLink)\n\nReturn the SPK/PCK segment descriptor associated to this link.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.file_id","page":"Low-level API","title":"Ephemerides.file_id","text":"file_id(link::SPKLink)\n\nReturn the DAF file index.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.list_id","page":"Low-level API","title":"Ephemerides.list_id","text":"list_id(link::SPKLink)\n\nReturn the index of the list containing the segments of the given SPK/PCK type.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.element_id","page":"Low-level API","title":"Ephemerides.element_id","text":"element_id(link::SPKLink)\n\nReturn the segment index in the inner SPK/PCK segment list.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.factor","page":"Low-level API","title":"Ephemerides.factor","text":"factor(link::SPKLink)\n\nReturn the direction multiplicative factor.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.reverse_link","page":"Low-level API","title":"Ephemerides.reverse_link","text":"reverse_link(link::SPKLink)\n\nReverse the sign, i.e. change the sign of the multiplicative factor, of the link.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.create_linktables","page":"Low-level API","title":"Ephemerides.create_linktables","text":"create_linktables(dafs::Vector{DAF})\n\nCreate the SPK and PCK SPKLinkTable for all the segments stores in the input DAFs.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.add_spklinks!","page":"Low-level API","title":"Ephemerides.add_spklinks!","text":"add_spklinks!(table::SPKLinkTable, daf::DAF, fid::Int)\n\nInsert in the input SPKLinkTable all the SPK or PCK links associated to  the segment descriptors of the input DAF.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#SPK-Segment-List","page":"Low-level API","title":"SPK Segment List","text":"","category":"section"},{"location":"api/lapi/","page":"Low-level API","title":"Low-level API","text":"Ephemerides.SPKSegmentList \nEphemerides.add_segment! \nEphemerides.get_segment\n\nEphemerides.SPK_SEGMENTLIST_MAPPING\nEphemerides.TCB_SEGMENTS\nEphemerides.TDB_SEGMENTS","category":"page"},{"location":"api/lapi/#Ephemerides.SPKSegmentList","page":"Low-level API","title":"Ephemerides.SPKSegmentList","text":"SPKSegmentList\n\nA container object to efficiently store all the different SPK segments that are contained  within a single DAF file.\n\n\n\nSPKSegmentList()\n\nInitialises an empty SPKSegmentList object.\n\nSee also\n\nSee also Ephemerides.add_segment!\n\n\n\n\n\n","category":"type"},{"location":"api/lapi/#Ephemerides.add_segment!","page":"Low-level API","title":"Ephemerides.add_segment!","text":"add_segment!(list::SPKSegmentList, spk::AbstractSPKSegment)\n\nAdd the SPK segment to the proper vector within the given Ephemerides.SPKSegmentList list \n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.get_segment","page":"Low-level API","title":"Ephemerides.get_segment","text":"get_segment(list::SPKSegmentList, lid::Int, eid::Int)\n\nReturn the segment contained in the lid list at index eid.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.SPK_SEGMENTLIST_MAPPING","page":"Low-level API","title":"Ephemerides.SPK_SEGMENTLIST_MAPPING","text":"SPK_SEGMENT_MAPPING\n\nA dictionary mapping SPK segment types to the field index of the SPKSegmentList.\n\n\n\n\n\n","category":"constant"},{"location":"api/lapi/#Ephemerides.TCB_SEGMENTS","page":"Low-level API","title":"Ephemerides.TCB_SEGMENTS","text":"TCB_SEGMENTS\n\nList of the SPK/PCK segment types for which the time argument is expressed in the TCB scale.\n\n\n\n\n\n","category":"constant"},{"location":"api/lapi/#Ephemerides.TDB_SEGMENTS","page":"Low-level API","title":"Ephemerides.TDB_SEGMENTS","text":"TDB_SEGMENTS\n\nList of the SPK/PCK segment types for which the time argument is expressed in the TDB scale. \n\n\n\n\n\n","category":"constant"},{"location":"api/lapi/#SPK-Segment-Types","page":"Low-level API","title":"SPK Segment Types","text":"","category":"section"},{"location":"api/lapi/#Abstract-SPK-Types","page":"Low-level API","title":"Abstract SPK Types","text":"","category":"section"},{"location":"api/lapi/","page":"Low-level API","title":"Low-level API","text":"Ephemerides.AbstractSPKHeader \nEphemerides.AbstractSPKCache \nEphemerides.AbstractSPKSegment\n\nEphemerides.cache \nEphemerides.spk_field","category":"page"},{"location":"api/lapi/#Ephemerides.AbstractSPKHeader","page":"Low-level API","title":"Ephemerides.AbstractSPKHeader","text":"AbstractSPKHeader\n\nAbstract type for all SPK segment type headers. \n\n\n\n\n\n","category":"type"},{"location":"api/lapi/#Ephemerides.AbstractSPKCache","page":"Low-level API","title":"Ephemerides.AbstractSPKCache","text":"AbstractSPKCache\n\nAbstract type for all SPK segment type caches.\n\n\n\n\n\n","category":"type"},{"location":"api/lapi/#Ephemerides.AbstractSPKSegment","page":"Low-level API","title":"Ephemerides.AbstractSPKSegment","text":"AbstractSPKSegment\n\nAbstract type for all SPK segment types.\n\n\n\n\n\n","category":"type"},{"location":"api/lapi/#Ephemerides.cache","page":"Low-level API","title":"Ephemerides.cache","text":"cache(spk::AbstractSPKSegment)\n\nReturn the segment cache data.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.spk_field","page":"Low-level API","title":"Ephemerides.spk_field","text":"spk_field(spk::AbstractSPKSegment)\n\nReturn the field number in the Ephemerides.SPKSegmentList associated to the given SPK  segment type.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#SPK-Type-1-and-21","page":"Low-level API","title":"SPK Type 1 and 21","text":"","category":"section"},{"location":"api/lapi/","page":"Low-level API","title":"Low-level API","text":"Ephemerides.SPKSegmentHeader1\nEphemerides.SPKSegmentCache1 \nEphemerides.SPKSegmentType1\n\nEphemerides.compute_mda_position \nEphemerides.compute_mda_velocity","category":"page"},{"location":"api/lapi/#Ephemerides.SPKSegmentHeader1","page":"Low-level API","title":"Ephemerides.SPKSegmentHeader1","text":"SPKSegmentHeader1 <: AbstractSPKHeader\n\nHeader instance for SPK segments of type 1 and 21.\n\nFields\n\nn – Int number of records in the segment \nndirs – Int number of directory epochs\nepochs – Storage for directory epochs or epochs (when ndirs = 0)\niaa - Int initial segment file address \netid – Int initial address for the epoch table (after all the MDA records)\nrecsize - Int Number of double numbers stored in each MDA record\nmaxdim - Int MDA dimension (fixed to 15 for type 1)\n\n\n\n\n\n","category":"type"},{"location":"api/lapi/#Ephemerides.SPKSegmentCache1","page":"Low-level API","title":"Ephemerides.SPKSegmentCache1","text":"SPKSegmentCache1 <: AbstractSPKCache\n\nCache instance for SPK segments of type 1 and 21. The fields contained within this cache  are taken from the FORTRAN NAIF's SPICE implementation for type 1 SPK segments. \n\n\n\n\n\n","category":"type"},{"location":"api/lapi/#Ephemerides.SPKSegmentType1","page":"Low-level API","title":"Ephemerides.SPKSegmentType1","text":"SPKSegmentType1 <: AbstractSPKSegment\n\nSegment instance for SPK segments of type 1 and 21, which contain Modified Difference Arrays  (MDA). This data type is normally used for spacecraft whose ephemerides are produced by JPL's  principal trajectory integrator DPTRAJ. \n\nFields\n\nhead – Segment header \ncache – Segment cache \n\nReferences\n\nSPK Required Reading\nSPICE Toolkit\n\n\n\n\n\n","category":"type"},{"location":"api/lapi/#Ephemerides.compute_mda_position","page":"Low-level API","title":"Ephemerides.compute_mda_position","text":"compute_mda_position(cache::SPKSegmentCache1, Δ::Number)\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.compute_mda_velocity","page":"Low-level API","title":"Ephemerides.compute_mda_velocity","text":"compute_mda_velocity(cache::SPKSegmentCache1, Δ::Number)\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#SPK-Type-2-and-3","page":"Low-level API","title":"SPK Type 2 and 3","text":"","category":"section"},{"location":"api/lapi/","page":"Low-level API","title":"Low-level API","text":"Ephemerides.SPKSegmentHeader2\nEphemerides.SPKSegmentCache2\nEphemerides.SPKSegmentType2","category":"page"},{"location":"api/lapi/#Ephemerides.SPKSegmentHeader2","page":"Low-level API","title":"Ephemerides.SPKSegmentHeader2","text":"SPKSegmentHeader2 <: AbstractSPKHeader\n\nHeader instance for SPK segments of type 2 and 3.\n\nFields\n\ntstart – Float64 initial epoch of the first record, in seconds since J2000\ntlen – Float64 interval length covered by each record, in seconds\norder – Int polynomial order \nN – Int number of coefficients in each window\nn – Int number of records in the segment\nrecsize – Int byte size of each logical record\nncomp – Int number of vector components\niaa – Int initial segment file address\ntype – Int SPK segment type, either 2 or 2\n\n\n\n\n\n","category":"type"},{"location":"api/lapi/#Ephemerides.SPKSegmentCache2","page":"Low-level API","title":"Ephemerides.SPKSegmentCache2","text":"SPKSegmentCache2 <: AbstractSPKCache\n\nCache instance for SPK segments of type 2 and 3.\n\nFields\n\nA – Chebyshev's polynomial coefficients, with size (ncomp, order)\np – Stores the record mid point and radius and scale factor\nbuff – Stores the buffers for the Chebyshev polynomials\nid – Index of the currently loaded logical record\n\n\n\n\n\n","category":"type"},{"location":"api/lapi/#Ephemerides.SPKSegmentType2","page":"Low-level API","title":"Ephemerides.SPKSegmentType2","text":"SPKSegmentType2 <: AbstractSPKSegment\n\nSegment instance for SPK segments of type 2 and 3, which contain Chebyshev polynomial  coefficients for the position and/or state of the body as function of time. This data type  is normally used for planet barycenters, and for satellites whose ephemerides are integrated.\n\nFields\n\nhead – Segment header \ncache – Segment cache \n\nReferences\n\nSPK Required Reading\nSPICE Toolkit\n\n\n\n\n\n","category":"type"},{"location":"api/lapi/#SPK-Type-8-and-12","page":"Low-level API","title":"SPK Type 8 and 12","text":"","category":"section"},{"location":"api/lapi/","page":"Low-level API","title":"Low-level API","text":"Ephemerides.SPKSegmentHeader8\nEphemerides.SPKSegmentCache8\nEphemerides.SPKSegmentType8","category":"page"},{"location":"api/lapi/#Ephemerides.SPKSegmentHeader8","page":"Low-level API","title":"Ephemerides.SPKSegmentHeader8","text":"SPKSegmentHeader8 <: AbstractSPKHeader\n\nHeader instance for SPK segments of type 8 and 12.\n\nFields\n\ntstart – Float64 segment starting epoch, in TDB seconds since J2000 \ntlen – Float64 interval length, in seconds\norder – Int interpolating polynomial degree\nN – Int group size\nn – Int number of states in the segment\niaa - Int initial segment file address \niseven – Bool true for even group size\ntype – Int SPK type (either 8 or 12)\n\n\n\n\n\n","category":"type"},{"location":"api/lapi/#Ephemerides.SPKSegmentCache8","page":"Low-level API","title":"Ephemerides.SPKSegmentCache8","text":"SPKSegmentCache8 <: AbstractSPKCache\n\nCache instance for SPK segments of type 8 and 12.\n\n\n\n\n\n","category":"type"},{"location":"api/lapi/#Ephemerides.SPKSegmentType8","page":"Low-level API","title":"Ephemerides.SPKSegmentType8","text":"SPKSegmentType8 <: AbstractSPKSegment\n\nSegment instance for SPK segments of type 8 and 12.\n\nFields\n\nhead – Segment header \ncache – Segment cache \n\nReferences\n\nSPK Required Reading\nSPICE Toolkit\n\n\n\n\n\n","category":"type"},{"location":"api/lapi/#SPK-Type-9-and-13","page":"Low-level API","title":"SPK Type 9 and 13","text":"","category":"section"},{"location":"api/lapi/","page":"Low-level API","title":"Low-level API","text":"Ephemerides.SPKSegmentHeader9\nEphemerides.SPKSegmentCache9\nEphemerides.SPKSegmentType9","category":"page"},{"location":"api/lapi/#Ephemerides.SPKSegmentHeader9","page":"Low-level API","title":"Ephemerides.SPKSegmentHeader9","text":"SPKSegmentHeader9 <: AbstractSPKHeader\n\nHeader instance for SPK segments of type 9 and 13.\n\nFields\n\nn – Int number of states in the segment\nndirs – Int number of epoch directories\nepochs – Storage for directory epochs or epochs (when ndirs = 0)\niaa - Int initial segment file address \netid – Int initial address for the epoch table (after all the state data)\norder – Int interpolating polynomial degree\nN – Int group size \niseven – Bool true for even group size\ntype – Int SPK type (either 9 or 13)\n\n\n\n\n\n","category":"type"},{"location":"api/lapi/#Ephemerides.SPKSegmentCache9","page":"Low-level API","title":"Ephemerides.SPKSegmentCache9","text":"SPKSegmentCache9 <: AbstractSPKCache\n\nCache instance for SPK segments of type 9 and 13.\n\n\n\n\n\n","category":"type"},{"location":"api/lapi/#Ephemerides.SPKSegmentType9","page":"Low-level API","title":"Ephemerides.SPKSegmentType9","text":"SPKSegmentType9 <: AbstractSPKSegment\n\nSegment instance for SPK segments of type 9 and 13.\n\nFields\n\nhead – Segment header \ncache – Segment cache \n\nReferences\n\nSPK Required Reading\nSPICE Toolkit\n\n\n\n\n\n","category":"type"},{"location":"api/lapi/#SPK-Type-18-and-19","page":"Low-level API","title":"SPK Type 18 and 19","text":"","category":"section"},{"location":"api/lapi/","page":"Low-level API","title":"Low-level API","text":"Ephemerides.SPKSegmentHeader18\nEphemerides.SPKSegmentCache18\n\nEphemerides.reset_indexes!\nEphemerides.update_header!\n\nEphemerides.SPKSegmentHeader19\nEphemerides.SPKSegmentCache19\nEphemerides.SPKSegmentType19\n\nEphemerides.find_minisegment\nEphemerides.load_minisegment!","category":"page"},{"location":"api/lapi/#Ephemerides.SPKSegmentHeader18","page":"Low-level API","title":"Ephemerides.SPKSegmentHeader18","text":"SPKSegmentHeader18 <: AbstractSPKHeader\n\nHeader instance for SPK segments of type 18.\n\nFields\n\nn – Int number of states in the segment\nndirs – Int number of epoch directories\nepochs – Storage for directory epochs or epochs (when ndirs = 0)\niaa - Int initial segment file address \netid – Int initial address for the epoch table (after all the state data)\norder – Int interpolating polynomial degree\nN – Int group size \nsubtype – Int type 18 subtype, either 0 (Hermite) or 1 (Lagrange)\npacketsize – Int packet size for each point, either 12 (Hermite) or 6 (Lagrange)\n\n\n\n\n\n","category":"type"},{"location":"api/lapi/#Ephemerides.SPKSegmentCache18","page":"Low-level API","title":"Ephemerides.SPKSegmentCache18","text":"SPKSegmentCache18 <: AbstractSPKCache\n\nCache instance for SPK segments of type 18.\n\n\n\n\n\n","category":"type"},{"location":"api/lapi/#Ephemerides.reset_indexes!","page":"Low-level API","title":"Ephemerides.reset_indexes!","text":"reset_indexes!(cache::SPKSegmentCache18)\n\nReset the cache indexes to force the coefficients reload.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.update_header!","page":"Low-level API","title":"Ephemerides.update_header!","text":"update_header!(head::SPKSegmentHeader18, daf::DAF, iaa, faa, type)\n\nUpdate the header of type 18 segments.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.SPKSegmentHeader19","page":"Low-level API","title":"Ephemerides.SPKSegmentHeader19","text":"SPKSegmentHeader19 <: AbstractSPKHeader\n\nHeader instance for SPK segments of type 19.\n\nFields\n\nn – Int number of states in the segment.\nndirs – Int number of epoch directories.\ntimes – Storage for interval directories or start times (when ndirs = 0).\niaa - Int initial segment file address.\netid – Int byte address for the interval table (after all the minisegment data).\nptid – Int byte for the pointer table.\nusefirst – Bool boundary flag, true if the preceding segment should be used.\ntype – Int either type 18 or 19.\n\n\n\n\n\n","category":"type"},{"location":"api/lapi/#Ephemerides.SPKSegmentCache19","page":"Low-level API","title":"Ephemerides.SPKSegmentCache19","text":"SPKSegmentCache19 <: AbstractSPKCache\n\nCache instance for SPK segments of type 19.\n\n\n\n\n\n","category":"type"},{"location":"api/lapi/#Ephemerides.SPKSegmentType19","page":"Low-level API","title":"Ephemerides.SPKSegmentType19","text":"SPKSegmentType19 <: AbstractSPKSegment\n\nSegment instance for SPK segments of type 18 and 19. Type 18 segments are treated as  special cases of a type 19 with a single mini-segment.\n\nFields\n\nhead – Segment header \ncache – Segment cache \n\nReferences\n\nSPK Required Reading\nSPICE Toolkit\n\n\n\n\n\n","category":"type"},{"location":"api/lapi/#Ephemerides.find_minisegment","page":"Low-level API","title":"Ephemerides.find_minisegment","text":"find_minirecord(daf::DAF, head::SPKSegmentHeader19, time::Number)\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.load_minisegment!","page":"Low-level API","title":"Ephemerides.load_minisegment!","text":"load_minisegment!(daf::DAF, head::SPKSegmentHeader19, cache::SPKSegmentCache19, index::Int)\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/","page":"Low-level API","title":"Low-level API","text":"note: Note\nSPK segments of type 18 are the only ones that do not posses a dedicated SPK segment type structure, because they are treated as special cases (i.e., single minisegments) of the type 19.","category":"page"},{"location":"api/lapi/#SPK-Type-20","page":"Low-level API","title":"SPK Type 20","text":"","category":"section"},{"location":"api/lapi/","page":"Low-level API","title":"Low-level API","text":"Ephemerides.SPKSegmentHeader20\nEphemerides.SPKSegmentCache20\nEphemerides.SPKSegmentType20","category":"page"},{"location":"api/lapi/#Ephemerides.SPKSegmentHeader20","page":"Low-level API","title":"Ephemerides.SPKSegmentHeader20","text":"SPKSegmentHeader20 <: AbstractSPKHeader\n\nHeader instance for SPK segments of type 20.\n\nFields\n\ndscale – Float64 length conversion factor\ntscale – Float64 time conversion factor\ntstart – Float64 initial epoch of the first record, in seconds since J2000\ntlen – Float64 interval length covered by each record, in seconds\nrecsize – Int byte size of each logical record\norder – Int polynomial order \nN – Int number of coefficients in each window\nn – Int number of records in the segment\niaa – Int initial segment file address\n\n\n\n\n\n","category":"type"},{"location":"api/lapi/#Ephemerides.SPKSegmentCache20","page":"Low-level API","title":"Ephemerides.SPKSegmentCache20","text":"SPKSegmentCache2 <: AbstractSPKCache\n\nCache instance for SPK segments of type 20.\n\nFields\n\nid – Index of the currently loaded logical record\np – Stores the record position constants\nA – Chebyshev's polynomial coefficients, with size (ncomp, order)\nbuff – Stores the buffers for the Chebyshev polynomials\n\n\n\n\n\n","category":"type"},{"location":"api/lapi/#Ephemerides.SPKSegmentType20","page":"Low-level API","title":"Ephemerides.SPKSegmentType20","text":"SPKSegmentType2 <: AbstractSPKSegment\n\nSegment instance for SPK segments of type 20, which contain Chebyshev polynomial coefficients  for the position and/or state of the body as function of time. This data type is normally  used for planet barycenters, and for satellites whose ephemerides are integrated.\n\nFields\n\nhead – Segment header \ncache – Segment cache \n\nReferences\n\nSPK Required Reading\nSPICE Toolkit\n\n\n\n\n\n","category":"type"},{"location":"api/lapi/#SPK-Utility-Functions","page":"Low-level API","title":"SPK Utility Functions","text":"","category":"section"},{"location":"api/lapi/","page":"Low-level API","title":"Low-level API","text":"Ephemerides.normalise_time\nEphemerides.find_logical_record \nEphemerides.get_coefficients!","category":"page"},{"location":"api/lapi/#Ephemerides.normalise_time","page":"Low-level API","title":"Ephemerides.normalise_time","text":"normalise_time(cache::SPKSegmentCache2, time::Number)\n\nTransform time in an interval between [-1, 1] for compliance with Chebyshev polynomials.\n\n\n\n\n\nnormalise_time(head::SPKSegmentHeader8, time::Number, index::Int)\n\nReturned a normalised time that starts at 1 at the beginning of the interval.\n\n\n\n\n\nnormalise_time(head::SPKSegmentHeader20, time::Number, index::Int)\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.find_logical_record","page":"Low-level API","title":"Ephemerides.find_logical_record","text":"find_logical_record(daf::DAF, head::SPKSegmentHeader1, time::Number)\n\n\n\n\n\nfind_logical_record(head::SPKSegmentHeader2, time::Number)\n\n\n\n\n\nfind_logical_record(head::SPKSegmentHeader8, time::Number)\n\n\n\n\n\nfind_logical_record(daf::DAF, head::SPKSegmentHeader1, time::Number)\n\n\n\n\n\nfind_logical_record(daf::DAF, head::SPKSegmentHeader18, time::Number)\n\n\n\n\n\nfind_logical_record(head::SPKSegmentHeader20, time::Number)\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.get_coefficients!","page":"Low-level API","title":"Ephemerides.get_coefficients!","text":"get_coefficients!(daf::DAF, head::SPKSegmentHeader1, cache::SPKSegmentCache1, index::Int)\n\n\n\n\n\nget_coefficients!(daf::DAF, head::SPKSegmentHeader2, cache::SPKSegmentCache2, index::Int)\n\n\n\n\n\nget_coefficients!(daf::DAF, head::SPKSegmentHeader8, cache::SPKSegmentCache8, index::Int)\n\n\n\n\n\nget_coefficients!(daf::DAF, head::SPKSegmentHeader9, cache::SPKSegmentCache9, index::Int)\n\n\n\n\n\nget_coefficients!(daf::DAF, head::SPKSegmentHeader18, cache::SPKSegmentCache18, first::Int, last::Int)\n\n\n\n\n\nget_coefficients!(daf::DAF, head::SPKSegmentHeader20, cache::SPKSegmentCache20, index::Int)\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Parsing","page":"Low-level API","title":"Parsing","text":"","category":"section"},{"location":"api/lapi/#Interpolating-Functions","page":"Low-level API","title":"Interpolating Functions","text":"","category":"section"},{"location":"api/lapi/#Caches","page":"Low-level API","title":"Caches","text":"","category":"section"},{"location":"api/lapi/","page":"Low-level API","title":"Low-level API","text":"Ephemerides.InterpCache \nEphemerides.get_buffer","category":"page"},{"location":"api/lapi/#Ephemerides.InterpCache","page":"Low-level API","title":"Ephemerides.InterpCache","text":"InterpCache{T}\n\n\n\n\n\n","category":"type"},{"location":"api/lapi/#Ephemerides.get_buffer","page":"Low-level API","title":"Ephemerides.get_buffer","text":"get_buffer(c::InterpCache, idx::int, x::Number)\n\nReturn the idx-th buffer from the corresponding DiffCache depending on the type of x. \n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Chebyshev-Polynomials","page":"Low-level API","title":"Chebyshev Polynomials","text":"","category":"section"},{"location":"api/lapi/","page":"Low-level API","title":"Low-level API","text":"Ephemerides.chebyshev\nEphemerides.∂chebyshev\nEphemerides.∂²chebyshev\nEphemerides.∂³chebyshev\nEphemerides.∫chebyshev","category":"page"},{"location":"api/lapi/#Ephemerides.chebyshev","page":"Low-level API","title":"Ephemerides.chebyshev","text":"chebyshev(cache::InterpCache, cₖ, t::Number, idx::Int, N::Int, ibuff::Int)\n\nEvaluate a sum of Cheybyshev polynomials of the first kind at t using a  recursive algorithm. It simultenously evalutes the 3 state components. idx is the  index of the starting row (in 0-based notation) in the matrix of coefficients cₖ. ibuff is the index of the first free buffer. \n\nnote: Note\nx is a re-work of the actual ascissa value that lies between [-1, 1]\n\nSee Also\n\nSee also ∂chebyshev, ∂²chebyshev and ∂³chebyshev\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.∂chebyshev","page":"Low-level API","title":"Ephemerides.∂chebyshev","text":"∂chebyshev(cache::InterpCache, cₖ, t::Number, idx::Int, N::Int, Δt, ibuff=1)\n\nEvaluate a sum of Cheybyshev polynomials of the first kind and its derivative at t  using a recursive algorithm. It simultenously evalutes the 3 state components. idx  is the index of the starting row (in 0-based notation) in the matrix of coefficients cₖ. ibuff is the index of the first free buffer. \n\nnote: Note\nx is a re-work of the actual ascissa value that lies between [-1, 1]\n\nSee Also\n\nSee also chebyshev, ∂²chebyshev and ∂³chebyshev\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.∂²chebyshev","page":"Low-level API","title":"Ephemerides.∂²chebyshev","text":"∂²chebyshev(cache::InterpCache, cₖ, t::Number, idx::Int, N::Int, Δt, ibuff=1)\n\nEvaluate a sum of Cheybyshev polynomials of the first kind and its two derivatives at t  using a recursive algorithm. It simultenously evalutes the 3 state components. idx  is the index of the starting row (in 0-based notation) in the matrix of coefficients cₖ. ibuff is the index of the first free buffer. \n\nnote: Note\nx is a re-work of the actual ascissa value that lies between [-1, 1]\n\nSee Also\n\nSee also chebyshev, ∂chebyshev and ∂³chebyshev\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.∂³chebyshev","page":"Low-level API","title":"Ephemerides.∂³chebyshev","text":"∂³chebyshev(cache::InterpCache, cₖ, t::Number, idx::Int, N::Int, Δt, ibuff=1)\n\nEvaluate a sum of Cheybyshev polynomials of the first kind and its three derivatives at t  using a recursive algorithm. It simultenously evalutes the 3 state components. idx  is the index of the starting row (in 0-based notation) in the matrix of coefficients cₖ. ibuff is the index of the first free buffer. \n\nnote: Note\nx is a re-work of the actual ascissa value that lies between [-1, 1]\n\nSee Also\n\nSee also chebyshev, ∂chebyshev and ∂²chebyshev\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.∫chebyshev","page":"Low-level API","title":"Ephemerides.∫chebyshev","text":"∫chebyshev(cache::InterpCache, cₖ, t::Number, N::Int, Δt, tlen, p₀)\n\nEvaluate the integral of a sum of Cheybyshev polynomials of the first kind using a recursive  algorithm. It simultenously evalutes the 3 state components. It assumes the Chebyshev polynomials  up to degree N have already been computed and are stored in the buffer with index ibuff.  tlen is the size of the record interval, Δt is the timescale factor, and p₀ is a  vector containing the position coefficients at the midpoint (i.e., when the integral is  evaluated at t = 0).\n\nnote: Note\nx is a re-work of the actual ascissa value that lies between [-1, 1]\n\n\n\n\n\n∫chebyshev(cache::InterpCache, cₖ, t::Number, N::Int, Δt, tlen, p₀)\n\nEvaluate the integral of a sum of Cheybyshev polynomials of the first kind using a recursive  algorithm. It simultenously evalutes the 3 state components. This function simultaneously  computes both the Chebyshev polynomials as well as their integrals.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Lagrange-Polynomials","page":"Low-level API","title":"Lagrange Polynomials","text":"","category":"section"},{"location":"api/lapi/","page":"Low-level API","title":"Low-level API","text":"Ephemerides.lagrange\nEphemerides.∂lagrange\nEphemerides.∂²lagrange","category":"page"},{"location":"api/lapi/#Ephemerides.lagrange","page":"Low-level API","title":"Ephemerides.lagrange","text":"lagrange(cache::InterpCache, states, x, idx::Int, N::Int)\n\nRecursively evaluate a Lagrange polynomial at x by using Neville's algorithm. This  function is valid only for equally-spaced polynomials. idx is the index of the desired  state and N is the number of coefficients of the polynomial. \n\nnote: Note\nx is a re-work of the actual ascissa value that starts at 1 \n\nSee Also\n\nSee also ∂lagrange and ∂²lagrange.\n\n\n\n\n\nlagrange(cache::InterpCache, states, epochs, x, idx::Int, N::Int)\n\nRecursively evaluate a Lagrange polynomial at x by using Neville's algorithm. This  function handles unequally-spaced polynomials, where the coefficients in states are  interpolated at epochs.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.∂lagrange","page":"Low-level API","title":"Ephemerides.∂lagrange","text":"∂lagrange(cache::InterpCache, states, x, idx::Int, N::Int, Δt::Number)\n\nRecursively evaluate a Lagrange polynomial and its derivative at x by using  Neville's algorithm. This function is valid only for equally-spaced polynomials. idx  is the index of the desired state, N is the number of coefficients of the polynomial and  Δtis the length of the polynomial interval\n\nnote: Note\nx is a re-work of the actual ascissa value that starts at 1\n\nSee Also\n\nSee also lagrange and ∂²lagrange\n\n\n\n\n\n∂lagrange(cache::InterpCache, states, epochs, x, idx::Int, N::Int)\n\nRecursively evaluate a Lagrange polynomial and its derivative at x by using  Neville's algorithm. This function handles unequally-spaced polynomials, where the  coefficients in states are interpolated at epochs.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.∂²lagrange","page":"Low-level API","title":"Ephemerides.∂²lagrange","text":"∂²lagrange(cache::InterpCache, states, x, idx::Int, N::Int, Δt::Number)\n\nRecursively evaluate a Lagrange polynomial and its two derivatives at x by using  Neville's algorithm. This function is valid only for equally-spaced polynomials. idx  is the index of the desired state, N is the number of coefficients of the polynomial and  Δtis the length of the polynomial interval\n\nnote: Note\nx is a re-work of the actual ascissa value that starts at 1\n\nSee Also\n\nSee also lagrange and ∂lagrange\n\n\n\n\n\n∂²lagrange(cache::InterpCache, states, epochs, x, idx::Int, N::Int)\n\nRecursively evaluate a Lagrange polynomial and its two derivatives at x by using  Neville's algorithm. This function handles unequally-spaced polynomials, where the  coefficients in states are interpolated at epochs.\n\nSee Also\n\nSee also lagrange and ∂lagrange\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Hermite-Polynomials","page":"Low-level API","title":"Hermite Polynomials","text":"","category":"section"},{"location":"api/lapi/","page":"Low-level API","title":"Low-level API","text":"Ephemerides.hermite\nEphemerides.∂hermite\nEphemerides.∂²hermite\nEphemerides.∂³hermite","category":"page"},{"location":"api/lapi/#Ephemerides.hermite","page":"Low-level API","title":"Ephemerides.hermite","text":"hermite(cache::InterpCache, states, x, idx::Int, N::Int, Δt::Number)\n\nEvalute a Hermite polynomial at x using a recursive algorithm. This function is valid  only for equally-spaced polynomials. idx is the index of the desired state, N  is the number of coefficients of the polynomial and Δt is the length of the polynomial  interval.\n\nnote: Note\nx is a re-work of the actual ascissa value that starts at 1 \n\nSee Also\n\nSee also ∂hermite, ∂²hermite and ∂³hermite.\n\n\n\n\n\nhermite(cache::InterpCache, states, epochs, x, idx::Int, N::Int)\n\nEvalute a Hermite polynomial at x using a recursive algorithm. This function handles  unequally-spaced polynomials, where the coefficients in states are interpolated  at epochs.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.∂hermite","page":"Low-level API","title":"Ephemerides.∂hermite","text":"∂hermite(cache::InterpCache, states, x, idx::Int, N::Int, Δt::Number)\n\nEvalute a Hermite polynomial and its derivative at x using a recursive algorithm.  This function is valid only for equally-spaced polynomials. idx is the index of the  desired state, N is the number of coefficients of the polynomial and Δt is the length  of the polynomial interval.\n\nnote: Note\nx is a re-work of the actual ascissa value that starts at 1 \n\nSee Also\n\nSee also hermite, ∂²hermite and ∂³hermite.\n\n\n\n\n\n∂hermite(cache::InterpCache, states, epochs, x, idx::Int, N::Int)\n\nEvalute a Hermite polynomial and its derivative at x using a recursive algorithm.  This function handles unequally-spaced polynomials, where the coefficients in states  are interpolated at epochs.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.∂²hermite","page":"Low-level API","title":"Ephemerides.∂²hermite","text":"∂²hermite(cache::InterpCache, states, x, idx::Int, N::Int, Δt::Number)\n\nEvalute a Hermite polynomial and its two derivatives at x using a recursive algorithm.  This function is valid only for equally-spaced polynomials. idx is the index of the  desired state, N is the number of coefficients of the polynomial and Δt is the length  of the polynomial interval.\n\nnote: Note\nx is a re-work of the actual ascissa value that starts at 1 \n\nSee Also\n\nSee also hermite, ∂hermite and ∂³hermite.\n\n\n\n\n\n∂²hermite(cache::InterpCache, states, epochs, x, idx::Int, N::Int)\n\nEvalute a Hermite polynomial and its two derivatives at x using a recursive algorithm.  This function handles unequally-spaced polynomials, where the coefficients in states  are interpolated at epochs.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.∂³hermite","page":"Low-level API","title":"Ephemerides.∂³hermite","text":"∂³hermite(cache::InterpCache, states, x, idx::Int, N::Int, Δt::Number)\n\nEvalute a Hermite polynomial and its three derivatives at x using a recursive algorithm.  This function is valid only for equally-spaced polynomials. idx is the index of the  desired state, N is the number of coefficients of the polynomial and Δt is the length  of the polynomial interval.\n\nnote: Note\nx is a re-work of the actual ascissa value that starts at 1 \n\nSee Also\n\nSee also hermite, ∂hermite and ∂²hermite.\n\n\n\n\n\n∂³hermite(cache::InterpCache, states, epochs, x, idx::Int, N::Int)\n\nEvalute a Hermite polynomial and its three derivatives at x using a recursive algorithm.  This function handles unequally-spaced polynomials, where the coefficients in states  are interpolated at epochs.\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Introspection","page":"Low-level API","title":"Introspection","text":"","category":"section"},{"location":"api/lapi/","page":"Low-level API","title":"Low-level API","text":"Ephemerides.AbstractEphemRecord\nEphemerides.initial_times\nEphemerides.final_times\n\nEphemerides.analyse_timespan ","category":"page"},{"location":"api/lapi/#Ephemerides.AbstractEphemRecord","page":"Low-level API","title":"Ephemerides.AbstractEphemRecord","text":"AbstractEphemRecord\n\nAbstract type for ephemeris segment records.\n\n\n\n\n\n","category":"type"},{"location":"api/lapi/#Ephemerides.initial_times","page":"Low-level API","title":"Ephemerides.initial_times","text":"initial_times(record::AbstractEphemRecord)\n\nRecover the initial times of each sub-window in which the ephemeris data of record is  defined, expressed in TDB seconds since J2000\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.final_times","page":"Low-level API","title":"Ephemerides.final_times","text":"final_times(record::AbstractEphemRecord)\n\nRecover the final times of each sub-window in which the ephemeris data of record is  defined, expressed in TDB seconds since J2000\n\n\n\n\n\n","category":"function"},{"location":"api/lapi/#Ephemerides.analyse_timespan","page":"Low-level API","title":"Ephemerides.analyse_timespan","text":"analyse_timespan(records)\n\nAnalyse a set of AbstractEphemRecord, returning the minimum and maximum covered  times, in TDB seconds since J2000, together with a continuity parameter.\n\nReferences\n\nCALCEPH C++ library\n\nSee Also\n\nSee also ephem_spk_timespan and ephem_pck_timespan.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/position/#Reading-Ephemeris-Data","page":"Reading Ephemeris Data","title":"Reading Ephemeris Data","text":"","category":"section"},{"location":"tutorials/position/","page":"Reading Ephemeris Data","title":"Reading Ephemeris Data","text":"This tutorials will walk you through the basic features and interfaces that allow you to compute translation and orientation data from binary ephemeris kernels.","category":"page"},{"location":"tutorials/position/#Computing-state-vectors","page":"Reading Ephemeris Data","title":"Computing state vectors","text":"","category":"section"},{"location":"tutorials/position/","page":"Reading Ephemeris Data","title":"Reading Ephemeris Data","text":"Ephemerides.jl allows the computation of a relative position between two points and its higher order derivatives up to order 3 (i.e., velocity, acceleration and jerk). All these computations are natively  thread-safe and compatible with Automatic Differentiation (AD) with respect to time via ForwardDiff.jl.","category":"page"},{"location":"tutorials/position/","page":"Reading Ephemeris Data","title":"Reading Ephemeris Data","text":"In particular, the following methods are available to compute translation data: ","category":"page"},{"location":"tutorials/position/","page":"Reading Ephemeris Data","title":"Reading Ephemeris Data","text":"ephem_vector3(eph, from, to, time)\nephem_vector6(eph, from, to, time)\nephem_vector9(eph, from, to, time)\nephem_vector12(eph, from, to, time)","category":"page"},{"location":"tutorials/position/","page":"Reading Ephemeris Data","title":"Reading Ephemeris Data","text":"They all share the same interface, requiring an EphemerisProvider object as the first input. from and to are integer numbers representing the ID of the center and target points that we desired. The time argument is expressed in TDB seconds since J2000.0.","category":"page"},{"location":"tutorials/position/","page":"Reading Ephemeris Data","title":"Reading Ephemeris Data","text":"note: Note\nDifferently, from traditional ephemerides readers, Ephemerides.jl is only meant to read the data stored in the binary kernels and it does not perform any concatenation of state vectors. This means that if data from point 399 is expressed with respect to point 3, we will only be able to compute the relative position of 339 with respect to 3 or viceversa, but not of 399 with respect to another point. The reason behind this is that Ephemerides.jl is meant to be used in combination with FrameTransformations.jl, which already enables tranformations between different user-defined point and axes.","category":"page"},{"location":"tutorials/position/","page":"Reading Ephemeris Data","title":"Reading Ephemeris Data","text":"An example to compute the position of the Moon (399) with respect to the Earth-Moon Barycenter (3) at J2000 (time = 0), is the following: ","category":"page"},{"location":"tutorials/position/","page":"Reading Ephemeris Data","title":"Reading Ephemeris Data","text":"using Ephemerides\n\n# Load an ephemeris kernel containing the requested data\nkernel = \"path_to_de440\"\neph = EphemerisProvider(kernel)\n\n# Compute the position\npos = ephem_vector3(eph, 3, 399, 0)","category":"page"},{"location":"tutorials/position/","page":"Reading Ephemeris Data","title":"Reading Ephemeris Data","text":"Instead, if one desires the whole state vector, up to the jerk components, the functions become: ","category":"page"},{"location":"tutorials/position/","page":"Reading Ephemeris Data","title":"Reading Ephemeris Data","text":"# Compute position and velocity \npv = ephem_vector6(eph, 3, 399, 0)\n\n# Compute position, velocity and acceleration\npva = ephem_vector9(eph, 3, 399, 0)\n\n# Compute position, velocity, acceleration and jerk\npvaj = ephem_vector12(eph, 3, 399, 0)","category":"page"},{"location":"tutorials/position/","page":"Reading Ephemeris Data","title":"Reading Ephemeris Data","text":"In all these examples, the returned data is always in the form of a StaticArray in order to minimise memory allocations.","category":"page"},{"location":"tutorials/position/","page":"Reading Ephemeris Data","title":"Reading Ephemeris Data","text":"warning: Warning\nSPK segments of types 1 and 21 do not natively support acceleration and jerk computations. However, these values can be computed by Automatic Differentiation (AD) of the position and/or velocity components.","category":"page"},{"location":"tutorials/position/#Computing-orientation-angles","page":"Reading Ephemeris Data","title":"Computing orientation angles","text":"","category":"section"},{"location":"tutorials/position/","page":"Reading Ephemeris Data","title":"Reading Ephemeris Data","text":"Similarly to position components, Ephemerides.jl also allows the computation of orientation angles and their derivatives up to order 3. All these computations are natively thread-safe and compatible with Automatic Differentiation (AD) with respect to time via ForwardDiff.jl.","category":"page"},{"location":"tutorials/position/","page":"Reading Ephemeris Data","title":"Reading Ephemeris Data","text":"In particular, the following methods are available to compute orientation data: ","category":"page"},{"location":"tutorials/position/","page":"Reading Ephemeris Data","title":"Reading Ephemeris Data","text":"ephem_rotation3(eph, from, to, time)\nephem_rotation6(eph, from, to, time)\nephem_rotation9(eph, from, to, time)\nephem_rotation12(eph, from, to, time)","category":"page"},{"location":"tutorials/position/","page":"Reading Ephemeris Data","title":"Reading Ephemeris Data","text":"Again, they all share the same interface, requiring an EphemerisProvider object as the first input. from and to are integer numbers representing the ID of the reference and target axes that we desired. The time argument is expressed in TDB seconds since J2000.0.","category":"page"},{"location":"tutorials/position/","page":"Reading Ephemeris Data","title":"Reading Ephemeris Data","text":"An example to compute the Euler angles of the PA440 axes (31008) with respect to the ICRF (1) at J2000 (time = 0), is the following: ","category":"page"},{"location":"tutorials/position/","page":"Reading Ephemeris Data","title":"Reading Ephemeris Data","text":"using Ephemerides\n\n# Load an ephemeris kernel containing the requested data\nkernel = \"path_to_pa440\"\neph = EphemerisProvider(kernel)\n\n# Compute the position\nang = ephem_rotation3(eph, 1, 31008, 0)","category":"page"},{"location":"tutorials/position/","page":"Reading Ephemeris Data","title":"Reading Ephemeris Data","text":"Instead, if one desires the whole vector, up to the 3rd order derivative, the functions become: ","category":"page"},{"location":"tutorials/position/","page":"Reading Ephemeris Data","title":"Reading Ephemeris Data","text":"# Compute angles and derivatives \npv = ephem_rotation6(eph, 1, 31008, 0)\npva = ephem_rotation9(eph, 1, 31008, 0)\npvaj = ephem_rotation12(eph, 1, 31008, 0)","category":"page"},{"location":"tutorials/position/","page":"Reading Ephemeris Data","title":"Reading Ephemeris Data","text":"The returned orientation data is always in the form of a StaticArray in order to minimise memory allocations.","category":"page"},{"location":"tutorials/position/","page":"Reading Ephemeris Data","title":"Reading Ephemeris Data","text":"note: Note\nDifferently from the translational data contained in SPK kernels, the orientation angles can only be computed in one direction, i.e., if the orientation of the Moon's Principal Axes (PA) is defined with respect to the ICRF, it is not possible to compute the rotation from the PA to the ICRF with this routine. ","category":"page"},{"location":"#Welcome-to-Ephemerides.jl!","page":"Home","title":"Welcome to Ephemerides.jl!","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ephemerides.jl is a Julia library that provides fast, thread-safe and allocation-free access to binary JPL SPK and PCK ephemeris files. Completely written in Julia, it enables Automatic-Differentiation (AD) via ForwardDiff.jl across all of its function calls. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"It outperforms both SPICE.jl and CALCEPH.jl calls for most types of SPK segments and supports state vector and orientation angles computation up to order 3 (jerk).","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nThis package is meant to be used in combination with FrameTransformations.jl, which enables transformations between different point and axes. Indeed, differently from traditional ephemeris readers such as CALCEPH and SPICE, this package is only meant to read the data stored in the binary kernels. It does not perform transformations between reference frames nor concatenations of state vectors. For example, if ephemeris data for point 399 (Earth) is defined with respect to point 3 (Earth-Moon Barycenter) in the ICRF axes, with this package we will only be able to compute the state vector from 399 to 3 or viceversa. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nAll the package routines have been extensively tested against both SPICE and CALCEPH.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package can be installed using Julia's package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg\n\njulia> Pkg.add(\"Ephemerides.jl\");","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Load SPK and PCK ephemeris kernels: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Ephemerides \n\n# Load a single SPK kernel \neph_spk = EphemerisProvider(\"de440.bsp\")\n\n# Load a single PCK kernel\neph_pck = EphemerisProvider(\"pa440.bsp\")\n\n# Load multiple SPK and PCK kernels\neph = EphemerisProvider([\"de440.bsp\", \"pa440.bsp\"])","category":"page"},{"location":"","page":"Home","title":"Home","text":"Inspect the kernels properties:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Retrieve the list of NAIF ID for all the available points \npoints = ephem_available_points(eph)\n\n# Retrieve the list of NAIF ID for all the available axes\naxes = ephem_available_axes(eph)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Retrieve state and orientation data:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# TDB seconds at 2000-01-01T12:00:00 (J2000)\ntime = 0.0\n\n# Compute the position of point 399 with respect to 3 at J2000\npos = ephem_vector3(eph, 3, 399, time)\n\n# Compute the position and its derivatives for point 299 with respect to 2\npvaj = ephem_vector12(eph, 2, 299, time)\n\n# Compute the orientation of axes 31006 (PA440) with respect to 1 (ICRF) at J2000\nangles = ephem_rotation3(eph, 1, 31006, time)","category":"page"},{"location":"#Current-Limitations","page":"Home","title":"Current Limitations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The supported JPL binary SPK/PCK segments types are: 1, 2, 3, 8, 9, 12, 13, 18, 19, 20, 21. \nBinary INPOP kernels are not supported. \nAcceleration and jerk computations are unavailable for SPK segments of type 1 and 21.","category":"page"},{"location":"api/api/#ephemerides_api","page":"Public API","title":"Public Documentation","text":"","category":"section"},{"location":"api/api/#Kernels-Loading-and-Inspection-Functions","page":"Public API","title":"Kernels Loading and Inspection Functions","text":"","category":"section"},{"location":"api/api/","page":"Public API","title":"Public API","text":"EphemerisProvider \nEphemerides.EphemRecordSPK \nEphemerides.EphemRecordPCK \n\nephem_timescale_id\n\nephem_spk_timespan\nephem_pck_timespan\n\nephem_spk_records\nephem_pck_records\n\nephem_get_points\nephem_get_axes","category":"page"},{"location":"api/api/#Ephemerides.EphemerisProvider","page":"Public API","title":"Ephemerides.EphemerisProvider","text":"EphemerisProvider(file::String)\nEphemerisProvider(files::Vector{String})\n\nCreate an EphemerisProvider instance by loading a single or multiple binary ephemeris  kernel files specified by files. Currently, only NAIF Double precision Array File (DAF) kernels (i.e., SPK and PCK) are accepted.\n\nExample\n\njulia> eph = EphemerisProvider(\"PATH_TO_KERNEL\")\nEphemerisProvider([...])\n\njulia> eph = EphemerisProvider([\"PATH_TO_KERNEL_1\", \"PATH_TO_KERNEL_2\"])\nEphemerisProvider([])\n\n\n\n\n\n","category":"type"},{"location":"api/api/#Ephemerides.EphemRecordSPK","page":"Public API","title":"Ephemerides.EphemRecordSPK","text":"EphemRecordSPK <: AbstractEphemRecord\n\nStore the SPK metadata relative to a given (target, center) objects pair.\n\nFields\n\ntarget – Int target object NAIF ID\ncenter – Int center object NAIF ID\naxes – Int reference axes ID \nt_start – start times of each sub-window, in TDB seconds since J2000\nt_end – final times of each sub-window, in TDB seconds since J2000\n\n\n\n\n\n","category":"type"},{"location":"api/api/#Ephemerides.EphemRecordPCK","page":"Public API","title":"Ephemerides.EphemRecordPCK","text":"EphemRecordPCK <: AbstractEphemRecord\n\nStore the PCK metadata relative to a given (target, center) axes pair.\n\nFields\n\ntarget – Int target axes NAIF ID\ncenter – Int center axes NAIF ID\nt_start – start times of each sub-window, in TDB seconds since J2000\nt_end – final times of each sub-window, in TDB seconds since J2000\n\n\n\n\n\n","category":"type"},{"location":"api/api/#Ephemerides.ephem_timescale_id","page":"Public API","title":"Ephemerides.ephem_timescale_id","text":"ephem_timescale_id(eph::EphemerisProvider)\n\nRetrieve a timescale ID associated with the ephemeris handler eph.  It returns 1 for Barycentric Dynamical Time (TDB) and 2 for Barycentric Coordinate Time (TCB).\n\nwarning: Warning\nEphemeris providers with mixed timescales are not supported. An error is thrown if in  the ephemeris handler some segments are defined in TDB and some other segments in TCB.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Ephemerides.ephem_spk_timespan","page":"Public API","title":"Ephemerides.ephem_spk_timespan","text":"ephem_spk_timespan(eph::EphemerisProvider)\n\nReturn the minimum and maximum time available in the SPK kernels loaded within eph, in  TDB seconds since J2000, together with a continuity parameter defined as follows: \n\n0 no SPK data is available.\n1 the quantities of all bodies are available for any time between the first and last time.\n2 the quantities of some bodies are available on discontinuous time intervals between the    first and last time.\n3 the quantities of each body are available on a continuous time interval between the first    and the last time, but not available for any time between the first and last time.\n\nReferences\n\nCALCEPH C++ library\n\nSee Also\n\nSee also ephem_pck_timespan.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Ephemerides.ephem_pck_timespan","page":"Public API","title":"Ephemerides.ephem_pck_timespan","text":"ephem_pck_timespan(eph::EphemerisProvider)\n\nReturn the minimum and maximum time available in the PCK kernels loaded within eph, in  TDB seconds since J2000, together with a continuity parameter defined as follows: \n\n0 no PCK data is available.\n1 the quantities of all axes are available for any time between the first and last time.\n2 the quantities of some axes are available on discontinuous time intervals between the    first and last time.\n3 the quantities of each axis are available on a continuous time interval between the first    and the last time, but not available for any time between the first and last time.\n\nReferences\n\nCALCEPH C++ library\n\nSee Also\n\nSee also ephem_spk_timespan.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Ephemerides.ephem_spk_records","page":"Public API","title":"Ephemerides.ephem_spk_records","text":"ephem_spk_records(eph::EphemerisProvider)\n\nReturn a list of EphemRecordSPK storing metadata relative to each (target, center) object pairs in the loaded SPK kernels. \n\n\n\n\n\n","category":"function"},{"location":"api/api/#Ephemerides.ephem_pck_records","page":"Public API","title":"Ephemerides.ephem_pck_records","text":"ephem_pck_records(eph::EphemerisProvider)\n\nReturn a list of EphemRecordPCK storing metadata relative to each (target, center) axes pairs in the loaded PCK kernels. \n\n\n\n\n\n","category":"function"},{"location":"api/api/#Ephemerides.ephem_get_points","page":"Public API","title":"Ephemerides.ephem_get_points","text":"ephem_get_points(eph::EphemerisProvider)\n\nReturn a list of NAIFIds representing bodies with available ephemeris data. \n\n\n\n\n\n","category":"function"},{"location":"api/api/#Ephemerides.ephem_get_axes","page":"Public API","title":"Ephemerides.ephem_get_axes","text":"ephem_get_axes(eph::EphemerisProvider)\n\nReturn a list of Frame IDs representing axes with available orientation data. \n\n\n\n\n\n","category":"function"},{"location":"api/api/#Computing-Positions","page":"Public API","title":"Computing Positions","text":"","category":"section"},{"location":"api/api/","page":"Public API","title":"Public API","text":"ephem_vector3\nephem_vector6\nephem_vector9\nephem_vector12","category":"page"},{"location":"api/api/#Ephemerides.ephem_vector3","page":"Public API","title":"Ephemerides.ephem_vector3","text":"ephem_vector3(eph::EphemerisProvider, from::Int, to::Int, time::Number)\n\nCompute the 3-elements state of one body (to) relative to another (from) at time, expressed in TDB/TCB seconds since J2000, in accordance with the kernel timescale.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Ephemerides.ephem_vector6","page":"Public API","title":"Ephemerides.ephem_vector6","text":"ephem_vector6(eph::EphemerisProvider, from::Int, to::Int, time::Number)\n\nCompute the 6-elements state of one body (to) relative to another (from) at time, expressed in TDB/TCB seconds since J2000, in accordance with the kernel timescale.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Ephemerides.ephem_vector9","page":"Public API","title":"Ephemerides.ephem_vector9","text":"ephem_vector9(eph::EphemerisProvider, from::Int, to::Int, time::Number)\n\nCompute the 9-elements state of one body (to) relative to another (from) at time, expressed in TDB/TCB seconds since J2000, in accordance with the kernel timescale.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Ephemerides.ephem_vector12","page":"Public API","title":"Ephemerides.ephem_vector12","text":"ephem_vector12(eph::EphemerisProvider, from::Int, to::Int, time::Number)\n\nCompute the 12-elements state of one body (to) relative to another (from) at time, expressed in TDB/TCB seconds since J2000, in accordance with the kernel timescale.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Computing-Orientation","page":"Public API","title":"Computing Orientation","text":"","category":"section"},{"location":"api/api/","page":"Public API","title":"Public API","text":"ephem_rotation3\nephem_rotation6\nephem_rotation9\nephem_rotation12","category":"page"},{"location":"api/api/#Ephemerides.ephem_rotation3","page":"Public API","title":"Ephemerides.ephem_rotation3","text":"ephem_rotation3(eph::EphemerisProvider, from::Int, to::Int, time::Number)\n\nCompute the 3-elements orientation angles of one set of axes (to) relative  to another (from) at time, expressed in TDB/TCB seconds since J2000, in accordance  with the kernel timescale.\n\nnote: Note\nFor the orientation angles, it is not possible to automatically compute the  reverse transformation , i.e., if the orientation of PA440 is defined  with respect to the ICRF, it is not possible to compute the rotation from the  PA440 to the ICRF with this routine.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Ephemerides.ephem_rotation6","page":"Public API","title":"Ephemerides.ephem_rotation6","text":"ephem_rotation6(eph::EphemerisProvider, from::Int, to::Int, time::Number)\n\nCompute the 6-elements orientation angles of one set of axes (to) relative  to another (from) at time, expressed in TDB/TCB seconds since J2000, in accordance  with the kernel timescale.\n\nnote: Note\nFor the orientation angles, it is not possible to automatically compute the  reverse transformation , i.e., if the orientation of PA440 is defined  with respect to the ICRF, it is not possible to compute the rotation from the  PA440 to the ICRF with this routine.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Ephemerides.ephem_rotation9","page":"Public API","title":"Ephemerides.ephem_rotation9","text":"ephem_rotation9(eph::EphemerisProvider, from::Int, to::Int, time::Number)\n\nCompute the 9-elements orientation angles of one set of axes (to) relative  to another (from) at time, expressed in TDB/TCB seconds since J2000, in accordance  with the kernel timescale.\n\nnote: Note\nFor the orientation angles, it is not possible to automatically compute the  reverse transformation , i.e., if the orientation of PA440 is defined  with respect to the ICRF, it is not possible to compute the rotation from the  PA440 to the ICRF with this routine.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Ephemerides.ephem_rotation12","page":"Public API","title":"Ephemerides.ephem_rotation12","text":"ephem_rotation12(eph::EphemerisProvider, from::Int, to::Int, time::Number)\n\nCompute the 12-elements orientation angles of one set of axes (to) relative  to another (from) at time, expressed in TDB/TCB seconds since J2000, in accordance  with the kernel timescale.\n\nnote: Note\nFor the orientation angles, it is not possible to automatically compute the  reverse transformation , i.e., if the orientation of PA440 is defined  with respect to the ICRF, it is not possible to compute the rotation from the  PA440 to the ICRF with this routine.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/inspect/#Kernels-Inspection","page":"Kernels Inspection","title":"Kernels Inspection","text":"","category":"section"},{"location":"tutorials/inspect/","page":"Kernels Inspection","title":"Kernels Inspection","text":"This tutorial will walk you through the basic features and interfaces that allow you to inspect the properties of binary ephemeris kernels.","category":"page"},{"location":"tutorials/inspect/#Available-Times","page":"Kernels Inspection","title":"Available Times","text":"","category":"section"},{"location":"tutorials/inspect/#Timescale","page":"Kernels Inspection","title":"Timescale","text":"","category":"section"},{"location":"tutorials/inspect/","page":"Kernels Inspection","title":"Kernels Inspection","text":"SPK and PCK segments support two types of ephemeris timescales, namely, TDB and TCB. The timescale of the loaded kernels can be retrieved as follows: ","category":"page"},{"location":"tutorials/inspect/","page":"Kernels Inspection","title":"Kernels Inspection","text":"using Ephemerides \n\n# Load the kernel\neph = EphemerisProvider(\"kernel.bsp\")\n\n# Retrieve the ID of the kernel timescales\nid = ephem_timescale_id(eph)","category":"page"},{"location":"tutorials/inspect/","page":"Kernels Inspection","title":"Kernels Inspection","text":"The retrieved ID is 1 for TDB and 2 for TCB. A value of -1 is returned if the kernels are empty. ","category":"page"},{"location":"tutorials/inspect/","page":"Kernels Inspection","title":"Kernels Inspection","text":"note: Note\nOnly one timescale is admissed within a single EphemerisProvider object, ","category":"page"},{"location":"tutorials/inspect/#Timespan","page":"Kernels Inspection","title":"Timespan","text":"","category":"section"},{"location":"tutorials/inspect/","page":"Kernels Inspection","title":"Kernels Inspection","text":"To retrieve the first and last available time in the ephemeris files associated to a provider  object, two functions are available to distinguish between SPK and PCK data: ","category":"page"},{"location":"tutorials/inspect/","page":"Kernels Inspection","title":"Kernels Inspection","text":"ephem_spk_timespan(eph)\nephem_pck_timespan(eph)","category":"page"},{"location":"tutorials/inspect/","page":"Kernels Inspection","title":"Kernels Inspection","text":"where eph is an EphemerisProvider instance. Both functions return the minimum and maximum available time in TDB seconds since J2000, as well as a continuity parameter defined as follows: ","category":"page"},{"location":"tutorials/inspect/","page":"Kernels Inspection","title":"Kernels Inspection","text":"0 no SPK or PCK data is available.\n1 the quantities of all bodies are available for any time between the first and last time.\n2 the quantities of some bodies are available on discontinuous time intervals between the    first and last time.\n3 the quantities of each body are available on a continuous time interval between the first    and the last time, but not available for any time between the first and last time.","category":"page"},{"location":"tutorials/inspect/#Available-Points-and-Axes","page":"Kernels Inspection","title":"Available Points and Axes","text":"","category":"section"},{"location":"tutorials/inspect/","page":"Kernels Inspection","title":"Kernels Inspection","text":"To retrieve the list of NAIF IDs with the points or axes that have available ephemeris data, these function should be called on an EphemerisProvider instance:","category":"page"},{"location":"tutorials/inspect/","page":"Kernels Inspection","title":"Kernels Inspection","text":"ephem_get_points(eph)\nephem_get_axes(eph)","category":"page"},{"location":"tutorials/inspect/#Segment-Records","page":"Kernels Inspection","title":"Segment Records","text":"","category":"section"},{"location":"tutorials/inspect/","page":"Kernels Inspection","title":"Kernels Inspection","text":"Position and orientation metadata relative to the records loaded in the ephemeris kernels can be retrieved with the following two functions, respectively:","category":"page"},{"location":"tutorials/inspect/","page":"Kernels Inspection","title":"Kernels Inspection","text":"ephem_spk_records(eph)\nephem_pck_records(eph)","category":"page"},{"location":"tutorials/inspect/","page":"Kernels Inspection","title":"Kernels Inspection","text":"Both functions return a vector of Ephemerides.EphemRecordSPK or Ephemerides.EphemRecordPCK ordered by priority, i.e., they use the highest priority records when there are multiple records that could satisfy the same target, center pair for a given epoch.","category":"page"},{"location":"tutorials/inspect/","page":"Kernels Inspection","title":"Kernels Inspection","text":"In particular SPK records contain the following information: ","category":"page"},{"location":"tutorials/inspect/","page":"Kernels Inspection","title":"Kernels Inspection","text":"target: NAIF ID of the target object\ncenter: NAIF ID of the center object\naxes: NAIF ID of the reference axes\nt_start: start times of each sub-window, in TDB seconds since J2000\nt_end: final times of each sub-window, in TDB seconds since J2000","category":"page"},{"location":"tutorials/inspect/","page":"Kernels Inspection","title":"Kernels Inspection","text":"Similarly, PCK records contain these information:","category":"page"},{"location":"tutorials/inspect/","page":"Kernels Inspection","title":"Kernels Inspection","text":"target: NAIF ID of the target axes\ncenter: NAIF ID of the reference axes\nt_start: start times of each sub-window, in TDB seconds since J2000\nt_end: final times of each sub-window, in TDB seconds since J2000","category":"page"},{"location":"tutorials/inspect/","page":"Kernels Inspection","title":"Kernels Inspection","text":"For PCK records, the reference axes ID is set into the center field. Please notice that whenever a gap between the data of a given pair of (center, target) objects is present, t_start and t_end will store the start and end times of each window with available data, respectively.","category":"page"}]
}
